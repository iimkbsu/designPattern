

소프트웨어 개발 과정
	- 요구사항분석 -> 설계 -> 구현 -> 테스트 
		*(위의 단계를 반복함)

	
디자인 패턴(Design Pattern)
	- 소프트웨어 개발 중 설계과정에서 사용함
	- 설계과정 중 반복적으로 겪는 문제(패턴)를 재사용할 수 있는 해결책으로 제시함 (클래스 간 관계를 맺는 방법으로 설명)
	- 클래스 간 관계는 UML을 사용하여 다이어그램으로 나타냄
	
		* 클래스(객체) 간 관계가 중요한 이유
			- 객체는 최소한의 기능을 가짐
			- 객체끼리 관계를 통해 더 큰 기능을 만들 수 있음
			- 필요한 기능만 최적화하여 개발 가능
			- 유지보수 편함
			- 새로운 기능 추가 편함


GoF 디자인 패턴 (Gang of Four Design Pattern) : 총 23개의 패턴으로 구성

	- 생성 패턴(5개) : 객체의 생성, 참조과정을 캡슐화 하여 새로운 객체가 생성되거나 변경되어도 전체 프로그램에 영향이 없도록 유연성을 더해주는 방식
	
		- 팩토리 메소드
			- 상위 클래스에서 인터페이스만 정의하고 하위 서브 클래스에서 객체 생성하도록 분리하여 캡슐화 함
			- 가상 생성자 패턴이라고도 함
			
		- 추상 팩토리
			- 구체적 클래스 없이 인터페이스를 통해 서로 연관/의존하는 객체들을 그룹으로 생성하여 추상적으로 표현
			- 연관되어있는 서브 클래스를 한 번에 교체하는 것이 가능
			
		- 빌더
			- 작게 분리된 인스턴스를 여럿 조합하여 객체 생성 (빌딩)
			- 객체 생성과 표현을 분리하여 동일 객체를 생성해도 서로다른 표현(결과)를 얻을 수 있음
			
		- 프로토타입
			- 원본 객체를 복제하여 생성 및 사용
			- 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우에 사용
			
		- 싱글톤
			- 하나의 클래스에 하나의 인스턴스만 생성 가능하게, 다른 클래스에서는 이 객체를 생성할 수 없고 참조만 가능, 메모리 절약 가능
			- 생성된 하나의 객체를 어디서든 참조 가능, 동시 참조는 안 됨
			
		
		
=====================		
		
		
	- 구조 패턴(7개) : 클래스, 객체들을 조합하여 더 큰 구조를 만드는 방식
	
		- 어댑터
			- 현재 사용 중인 인터페이스와 기존 클래스의 인터페이스의 호환성이 다를 때 이용할 수 있도록 함
			
		- 브릿지
			- 어떤 시스템을 기능계층과 구현계층으로 분리하여 구현함으로써 변화를 최소화하고 확장을 용이하게 함 (마치 계층 사이에 브릿지로 연결된 것 처럼)
			- 기존 시스템에 새로운 기능을 추가할 때 기능계층을 사용하여 변화를 최소화
			- 기존 시스템의 기능을 구현계층(인터페이스)을 통해 사용함으로써 변화없이 확장을 용이하게 함
			
		- 컴포지트
			- 여러 객체를포함한 복합겍체와 단일 객체를 구분 없이 다루기 위함 (단일체와 복합체를 하나의 공통타입으로 처리)
			- 객체트리구조를 만들어 디렉토리 형식처럼 복합객체 안에 복합겍체가 포함되는 구조를 구현
			
		- 데코레이터
			- 객체 간 결합을 통해 능동적으로 기능들 확장
			- 어떤 객체에 기능을 추가할 때 기능을 추가하는 것이 아니라 객체를 덧붙여 꾸미는 방식으로 구현
			
		- 파사드
			- 기능이 많고 복잡한 서브 클래스를 피하기 위해 상위에서 인터페이스를 구성하여 서브 클래스에서 기능을 간편하게 사용하도록 함
			- 서브 클래스들을 통합하는 인터페이스를 제공하는 wrapper 객체 필요
			
		- 플라이웨이트(경량)
			- 필요에 따라 매번 인스턴스를 생성하면 메모리 부하가 걸리므로, 생성을 자제하고 최대한 한 번 생성한 인스턴스를 공유하여 재사용함으로써 메모리 절약
			- 다수의 유사겍체를 생성할 때 사용
			
		- 프록시
			- 어떤 객체에서, 접근이 어려운 객체에 접근할 때 그 사이에서 인터페이스 역할을 수행함
			- 네트워크 연결, 대용량 메모리 객체의 접근 등에 주로 사용
		
		
====================		
		
		
	- 행위 패턴(11개) : 클래스, 객체들의 행위(상호작용) 방법 정의, 책임 분배 정의, 여러 객체로 나눠서 결합도 최소화 가능
	
		- 인터프리터
			- SQL이나 통신 프로토콜을 개발할 때 언어에 문법 표현을 정의하는 패턴
			
		- 탬플릿 메소드
			- 상위 클레스에서 골격 정의, 하위 클래스로 갈수록 세부적, 구체적 처리 정의
			- 유사 서브 클래스, 공통 내용을 상위 클래스에 묶어서 정의함으로써 코드양 줄이고 유지보수 용이
			
		- 책임연쇄
			- 요청 처리 객체를 둘 이상 만들어 처리하지 못한 경우 다음 객체가 책임지게 함
			- 요청 처리 객체들을 체인(고리)으로 묶어 요청이 처리될 때 까지 연쇄하여 넘어감
			
		- 커맨드
			- 요청 자체를 객체로 캡슐화하여 재사용하거나, 요청을 취소할 수 있도록 요청 정보를 저장하여 로그에 남김
			- 요청에서 사용하는 명령어들을 일반 클래스, 추상 클래스로 분리하여 단순화함
			
		- 이터레이터(반복자)
			- container/aggregator의 종류에 따라 구성 데이터를 얻는 방법이 서로 다른 것을 반복자를 통해 통일시켜 표준화된 API를 제공
			- 내부 표현 방법의 노출 없이 다양한 자료구조에 대해 순차적인 접근이 가능함
			
		- 메디에이터(중재자)
			- 객체들 간의 상호작용 자체를 객체로 캡슐화하는 패턴
			- 객체 사이의 의존성을 줄여 결합도 감소시킬 수 있음
			- 중재자는 객체들 간의 통제/지시 역할 수행
			
		- 메멘토(기억하기)
			- 특정 시점의 객체 상태 자체를 객체화함으로써 필요에 의해 그 시점으로 객체 상태를 돌릴 수 있는 기능 제공
			- 기억했다가 사용하기
			
		- 옵저버(관찰자)
			- 객체의 상태 변화를 상속된 객체에게 전달하는 패턴
			- 분산 시스템의 이벤트 생성, 발행, 수신할 때 사용
			
		- 전략(Strategy)
			- 동일 계열 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의함
			- 클라는 원하는 알고리즘을 독립적으로 선택, 사용 가능하고 클라에 영향없이 알고리즘 변경 가능(전략변경가능)
			
		- 비지터(방문자)
			- 각 클래스(객체)의 처리기능(메소드)만 분리하여 별도 클래스로 정의함으로써 처리기능이 필요할 때만 처리 클래스에 방문함
			
		- 스테이트(상태)
			- 객체 상태를 객체로 캡슐화 하고 이를 참조하여 상태에 따라 다른 동작을 처리해야 할 때 사용
		
		

		
			* Container (= Aggregator)
				- 같은 유형의 데이터 항목을 여러 개 묶은 것
				- 종류 : Array, LinkedList, Tree, Map, Table, Graph 등
	
	
	
	
	
	
	
	
	
	
	
	
	

